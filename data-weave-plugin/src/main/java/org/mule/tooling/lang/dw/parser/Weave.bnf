{
  parserClass="org.mule.tooling.lang.dw.parser.WeaveParser"
  parserUtilClass="org.mule.tooling.lang.dw.parser.WeaveParserUtil"
  psiImplUtilClass = 'org.mule.tooling.lang.dw.parser.psi.WeavePsiImplUtils'
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  psiClassPrefix="Weave"
  psiImplClassSuffix="Impl"
  psiPackage="org.mule.tooling.lang.dw.parser.psi"
  psiImplPackage="org.mule.tooling.lang.dw.parser.psi.impl"
  elementTypeHolderClass="org.mule.tooling.lang.dw.parser.psi.WeaveTypes"
  elementTypeClass="org.mule.tooling.lang.dw.parser.WeaveElementType"
  tokenTypeClass="org.mule.tooling.lang.dw.parser.WeaveTokenType"

  tokens = [
        L_PARREN='('
        R_PARREN=')'

        L_CURLY='{'
        R_CURLY='}'
        L_BRACKET='['
        R_BRACKET=']'
        SUB_TYPE='<:'
        COMMA=','
        COLON=':'
        FAT_ARROW='=>'

        LINE_COMMENT="regexp://([^\r\n])*?"

        DOUBLE_QUOTED_STRING="regexp:\"([^\\\"\r\n]|\\[^\r\n])*\"?"
        SINGLE_QUOTED_STRING="regexp:'([^\\\'\r\n]|\\[^\r\n])*'?"

        //
        DOCUMENT_SEPARATOR="---"

        NOT_EQUAL="!="
        SIMILAR="~="
        EQUAL="=="
        EQ="="
        LESS="<"
        LESS_EQUAL="<="
        GREATER=">"
        GREATER_EQUAL=">="

        PLUS="+"
        MINUS="-"
        MULTIPLY="*"
        DIVISION="/"
        MODULO="%"

        AT="@"
        QUESTION="?"
        ESCLAMATION="!"
        HASH="#"

        AND_KEYWORD="and"
        OR_KEYWORD="or"

        ARROW_TOKEN="->"

        WHEN="when"

        TRUE_LITERAL="true"
        FALSE_LITERAL="false"
        RULE_NULL_LITERAL="null"

        VERSION_DIRECTIVE_KEYWORD="%dw"
        INPUT_DIRECTIVE_KEYWORD="%input"
        VAR_DIRECTIVE_KEYWORD="%var"
        FUNCTION_DIRECTIVE_KEYWORD="%function"
        NAMESPACE_DIRECTIVE_KEYWORD="%namespace"
        TYPE_DIRECTIVE_KEYWORD="%type"


        OR="|"
        XOR="^"
        AND="&"
  ]

    extends(".*(Directive)")=Directive
    extends(".*(Expression|Literal)")=Expression
    extends(".*(Type)")=Type
    extends(".*(Pattern)")=Pattern
    pin(".*Directive") =1

}

root ::= Document

Document ::= Header ('---'  Body) ? | Body{
    implements="com.intellij.psi.NavigatablePsiElement"
    methods=[getPresentation]
}

Header::= Directive+ {pin=2}

Directive
         ::= VersionDirective
           | NamespaceDirective
           | VariableDirective
           | OutputDirective
           | InputDirective
           | TypeDirective
           | ImportDirective
           | FunctionDirective {recoverWhile=HeaderRecover}

private HeaderRecover::= !('---'|OUTPUT_DIRECTIVE_KEYWORD|'%type'|'%function'|'%namespace'|'%var'|'%dw'|'%input'|IMPORT_DIRECTIVE_KEYWORD)

VersionDirective::= '%dw'  DOUBLE_LITERAL

ImportDirective::= IMPORT_DIRECTIVE_KEYWORD (ImportedElement (',' ImportedElement)* 'from')? FqnIdentifier

ImportedElement::= Identifier ('as' Identifier)?

NamespaceDirective::= '%namespace' Identifier NAMESPACE_URI

VariableDirective::= '%var' VariableDefinition

OutputDirective::= OUTPUT_DIRECTIVE_KEYWORD (":" Type)? DataFormat Options?

TypeDirective::= '%type' TypeDefinition TypeParameterDeclaration?

TypeDefinition::=Identifier '=' TypeLiteral

FunctionDirective::= '%function' FunctionDefinition

FunctionDefinition::=Identifier TypeParameterDeclaration? L_PARREN ( FunctionParameter ( ',' FunctionParameter )* )? R_PARREN ( ":" Type "=" | "=")? Expression {
     methods = [getName setName getNameIdentifier]
     implements="org.mule.tooling.lang.dw.parser.psi.WeaveNamedElement"
     mixin="org.mule.tooling.lang.dw.parser.psi.WeaveNamedElementImpl"
     pin=3
}

Schema::= '{' ( SchemaElement ( ',' SchemaElement )* )? '}'

SchemaElement::= Identifier ':' LiteralExpression

InputDirective::= '%input' VARIABLE_DECLARATION DataFormat Options?

Options::= OptionElement ( ',' OptionElement )*

OptionElement::= Identifier '=' LiteralExpression

Body ::= Expression

ObjectExpression ::= SingleKeyValuePairObj | MultipleKeyValuePairObj {
    implements="com.intellij.psi.NavigatablePsiElement"
    methods=[getPresentation]
}

SingleKeyValuePairObj ::= KeyValuePair

MultipleKeyValuePairObj::= '{' KeyValuePairWithComma* '}'

private KeyValuePairWithComma ::= (KeyValuePair | DynamicKeyValuePair) (',' | &'}')

KeyValuePair::= ConditionalKeyValuePair
           | SimpleKeyValuePair

DynamicKeyValuePair ::= EnclosedExpression

SimpleKeyValuePair ::= Key ':' Expression
{
    implements="com.intellij.psi.NavigatablePsiElement"
    methods=[getPresentation]
}
ConditionalKeyValuePair ::= '(' Key ':' Expression ')' 'when' Expression

Key::=  KeyExpression Attributes?

KeyExpression::= DeclaredNamespace? (Identifier
           | StringLiteral
           | EnclosedExpression)

DeclaredNamespace::= Identifier '#'

Attributes::= '@(' ( AttributeElement ( ',' AttributeElement )* )? ')'

AttributeElement::= ConditionalAttribute
           | Attribute
           | EnclosedExpression

Attribute::= KeyExpression ':' Expression

ConditionalAttribute::= '(' KeyExpression ':' Expression ')' 'when' Expression {pin = 6}

Expression::= ConditionalExpression|
            MatchExpression|
            BinaryExpression|
            ClojureExpression|
            AsExpression|
            DefaultValueExpression|
            OrExpression|
            AndExpression|
            EqualityExpression|
            IsExpression|
            GreaterThanExpression|
            AdditionSubtractionExpression|
            RightLeftExpression|
            MultiplicationDivisionExpression|
            FunctionCallExpression|
            DotSelectorExpression|
            FilterSelectorExpression|
            BracketSelectorExpression|
            DynamicSelectorExpression|
            RangeSelectorExpression|
            UsingExpression|
            ValueExpression

MatchExpression ::= Expression RULE_MATCH_LITERAL (PatternMatcherExpression )

PatternMatcherExpression ::= '{' Pattern+ '}'

Pattern ::= RegexPattern 
          | NamedRegexPattern 
          | TypePattern 
          | NamedTypePattern 
          | LiteralPattern 
          | NamedLiteralPattern 
          | ExpressionPattern 
          | DefaultPattern

LiteralPattern ::= CASE_KEYWORD LiteralExpression '->' Expression

ExpressionPattern ::= CASE_KEYWORD Identifier 'when' Expression '->' Expression {
     methods = [getName setName getNameIdentifier]
     implements="org.mule.tooling.lang.dw.parser.psi.WeaveNamedElement"
     mixin="org.mule.tooling.lang.dw.parser.psi.WeaveNamedElementImpl"
}

NamedLiteralPattern ::= CASE_KEYWORD Identifier ':' LiteralExpression '->' Expression {
     methods = [getName setName getNameIdentifier]
     implements="org.mule.tooling.lang.dw.parser.psi.WeaveNamedElement"
     mixin="org.mule.tooling.lang.dw.parser.psi.WeaveNamedElementImpl"
}

TypePattern ::= CASE_KEYWORD Type '->' Expression

NamedTypePattern ::= CASE_KEYWORD Identifier "is" TypeLiteral '->' Expression {
    methods = [getName setName getNameIdentifier]
    implements="org.mule.tooling.lang.dw.parser.psi.WeaveNamedElement"
    mixin="org.mule.tooling.lang.dw.parser.psi.WeaveNamedElementImpl"
}

RegexPattern ::= CASE_KEYWORD RULE_ANY_REGEX '->' Expression

NamedRegexPattern ::= CASE_KEYWORD Identifier ":" AnyRegexLiteral '->' Expression {
    methods = [getName setName getNameIdentifier]
    implements="org.mule.tooling.lang.dw.parser.psi.WeaveNamedElement"
    mixin="org.mule.tooling.lang.dw.parser.psi.WeaveNamedElementImpl"
}

DefaultPattern ::= OTHERWISE '->' Expression

ValueExpression::= ObjectExpression
                  |RangeExpression
                  |ArrayExpression
                  |VariableReferenceExpression
                  |EnclosedExpression
                  |LiteralExpression

ConditionalExpression
         ::= Expression  ( WHEN | UNLESS ) Expression OTHERWISE Expression {pin=2}

BinaryExpression ::= Expression Identifier Expression
    {
        pin=2
        methods=[ getLeft  getRight]
    }

AsExpression
         ::= Expression  AS TypeLiteral {pin=2}

DefaultValueExpression
         ::= Expression DEFAULT Expression {pin=2}

OrExpression
         ::= Expression  'or' Expression {pin=2}

AndExpression
         ::= Expression  'and' Expression {pin=2}

EqualityExpression
         ::= Expression ( '==' | '!=' | '~=' ) Expression {pin=2}

IsExpression
         ::= Expression IS TypeLiteral {pin=2}

GreaterThanExpression
         ::= Expression  ( '>' | '>=' | '<' | '<=' ) Expression {pin=2}

AdditionSubtractionExpression
         ::= Expression  ( '+' | '-' ) Expression {pin=2}

RightLeftExpression
         ::= Expression '>''>' Expression {pin=2}

MultiplicationDivisionExpression ::= Expression  ( '*' | '/' ) Expression {pin=2}

FunctionCallExpression ::= Expression '(' ( Expression ( ',' Expression )* )? ')'


UsingExpression ::=USING '(' VariableDefinition ( ',' VariableDefinition )* ')' Expression {pin=1}

EnclosedExpression ::= '(' Expression ')'

//Selectors
DotSelectorExpression ::=Expression ( '..' | '.' ) Selector {pin=2}

RangeSelectorExpression ::=Expression RULE_RANGE_LITERAL

DynamicSelectorExpression ::=Expression'[' Expression ']'

FilterSelectorExpression ::=Expression'[' '?' EnclosedExpression ']'

BracketSelectorExpression::=Expression'[' Selector ']'


Selector ::= (ValueSelector |
         AttributeSelector |
         SchemaSelector |
         MultiValueSelector) ('!'| '?')?

ValueSelector ::= (DeclaredNamespace? (StringLiteral|Identifier))

AttributeSelector ::='@'(DeclaredNamespace? (StringLiteral|Identifier))?

SchemaSelector ::='^'(DeclaredNamespace? (StringLiteral|Identifier))?

MultiValueSelector ::= '*'(DeclaredNamespace? (StringLiteral|Identifier))

ClojureExpression ::=  '(' ( FunctionParameter ( ',' FunctionParameter )* )? ')' '->' Expression

VariableReferenceExpression ::= FqnIdentifier
//{
//        methods = [getVariableName getReference getName setName getNameIdentifier]
//        implements="org.mule.tooling.lang.dw.parser.psi.WeaveNamedElement"
//        mixin="org.mule.tooling.lang.dw.parser.psi.WeaveNamedElementImpl"
//   }

VariableDefinition ::= VARIABLE_DECLARATION '='  Expression  {
            methods=[getVariableName getVariableValue getName setName getNameIdentifier]
            mixin="org.mule.tooling.lang.dw.parser.psi.WeaveVariableImpl"
            implements="org.mule.tooling.lang.dw.parser.psi.WeaveVariable"
            name="Variable"
        }

private VARIABLE_DECLARATION ::= Identifier (":" Type)?

//Literal Values
LiteralExpression
         ::= BooleanLiteral
           | NullLiteral
           | StringLiteral
           | NumberLiteral
           | AnyDateLiteral
           | AnyRegexLiteral
           | LambdaLiteral
           | UndefinedLiteral
           | TypeLiteral

UndefinedLiteral ::= '?''?''?'

LambdaLiteral ::= TypeParameterDeclaration? '(' ( FunctionParameter ( ',' FunctionParameter )* )? ')' '->' Expression

private TypeParameterDeclaration ::= '<' (TypeParameter (',' TypeParameter)*)? '>'

FunctionParameter ::= VARIABLE_DECLARATION ('=' Expression)?  {
        methods=[getVariableName getVariableValue getName setName getNameIdentifier]
        mixin="org.mule.tooling.lang.dw.parser.psi.WeaveVariableImpl"
        implements="org.mule.tooling.lang.dw.parser.psi.WeaveVariable"

     }

NullLiteral ::= RULE_NULL_LITERAL

BooleanLiteral ::= TRUE_LITERAL
                        | FALSE_LITERAL

StringLiteral ::= DOUBLE_QUOTED_STRING
                      | SINGLE_QUOTED_STRING { methods = [getValue] }

AnyDateLiteral::= RULE_ANY_DATE

AnyRegexLiteral::= RULE_ANY_REGEX

RangeLiteral::= RULE_RANGE_LITERAL

DynamicRangeExpression::= '[' Expression RULE_WS+ '..' RULE_WS+ Expression ']'

RangeExpression::= RangeLiteral|DynamicRangeExpression

ArrayExpression::= '[' ( ArrayElement ( ',' ArrayElement )* )? ']'
{
    implements="com.intellij.psi.NavigatablePsiElement"
    methods=[getPresentation]
}

private ArrayElement::= Expression
                | '(' Expression ')' 'when' Expression {pin = 4}

TypeLiteral ::= Type Schema?

Type ::=
        UnionType |
        LambdaType |
        ObjectType |
        ArrayType |
        TypeType |
        SimpleType |
        ReferenceType


TypeParameter ::= Identifier ( '<:' Type)?

UnionType ::= Type '|' Type {pin= 2}

ObjectType ::=  ExpandedObjectType | SimpleObjectType

private SimpleObjectType ::= ('{' ((KeyValuePairType) (',' KeyValuePairType)*)? '}') {pin = 1}

private ExpandedObjectType ::= OBJECT_KEYWORD ('<''{' ((KeyValuePairType) (',' KeyValuePairType)*)? '}''>')? {pin = 1}

KeyValuePairType ::=  KeyType ('?')? ":" Type

KeyType ::= NameType AttributesType?

AttributesType ::= "@""(" NameType ":" Type ")" {pin= 1}

NameType ::= ((Identifier"#")?Identifier | StringLiteral) | '('TypeParameter')'

ArrayType ::= ARRAY_KEYWORD ('<' Type '>')?

TypeType ::= TYPE_KEYWORD ('<' Type '>')?

LambdaType ::= '(' LambdaTypeParameter (',' LambdaTypeParameter)* ')' '=>' Type {pin= 5}

LambdaTypeParameter ::= Type | Identifier ':' Type

ReferenceType ::= FqnIdentifier ('<' Type (',' Type)* '>')?

SimpleType ::= SIMPLE_TYPE_LITERAL

DataFormat ::= RULE_MIME_TYPE

NumberLiteral ::= DOUBLE_LITERAL | INTEGER_LITERAL

FqnIdentifier ::= CustomLoader? IdentifierPackage Identifier

IdentifierPackage ::= (Identifier "::")*

CustomLoader ::= Identifier"!"

Identifier ::= (DOLLAR_VARIABLE | ID | '+''+' | '-''-' | 'match')  {methods = [getName] }
